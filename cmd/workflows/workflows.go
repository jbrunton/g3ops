package workflows

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/fatih/color"
	"github.com/jbrunton/g3ops/cmd/styles"

	"github.com/google/go-jsonnet"
	"github.com/jbrunton/g3ops/lib"
	"github.com/spf13/cobra"
)

const template = `
local git_opts = {
  main_branch: 'master',
  user: 'jbrunton-ci-minion',
  email: 'jbrunton-ci-minion@outlook.com'
};

local build_job = {
  steps: [
    {
      name: 'commit',
      run: |||
        git config --global user.name "%(user)%s"
        git config --global user.email "%(email)%s"
        g3ops commit build ${{ matrix.service }}
        git push origin:%(main_branch)s
      ||| % git_opts
    }
  ]
};

local workflow = {
  on: {
    pull_request: {
      branches: [git_opts.main_branch]
    },
    push: {
      branches: [git_opts.main_branch]
    }
  },
  jobs: [
    build_job
  ],
};

std.manifestYamlDoc(workflow)
`

func getWorkflowTemplates(workflowsDir string, context *lib.G3opsContext) []string {
	files := []string{}
	err := filepath.Walk(workflowsDir, func(path string, f os.FileInfo, err error) error {
		if filepath.Ext(path) == ".jsonnet" {
			files = append(files, path)
		}
		return nil
	})

	if err != nil {
		panic(err)
	}

	return files
}

func getWorkflowName(workflowsDir string, filename string) string {
	templateDir, templateFileName := filepath.Split(filename)
	if templateFileName == "template.jsonnet" {
		// Check to see if the file is a top level template.
		if filepath.Clean(templateDir) != filepath.Clean(workflowsDir) {
			// If the file is called template.jsonnet and it's in a subdirectory, then rename it to the directory name.
			// E.g. "workflows/my-workflow/template.jsonnet" returns "my-workflow"
			return filepath.Base(templateDir)
		}
	}
	// In all other cases, simply return the name of the file less the extension.
	// E.g. "workflows/my-workflow.jsonnet" returns "my-workflow"
	return strings.TrimSuffix(templateFileName, filepath.Ext(templateFileName))
}

func newGenerateWorkflowCmd() *cobra.Command {
	return &cobra.Command{
		Use:   "generate",
		Short: "Generates workflow files",
		Run: func(cmd *cobra.Command, args []string) {
			context, err := lib.GetContext(cmd)
			if err != nil {
				fmt.Println(styles.StyleError(err.Error()))
				os.Exit(1)
			}

			vm := jsonnet.MakeVM()
			vm.StringOutput = true
			vm.ErrorFormatter.SetColorFormatter(color.New(color.FgRed).Fprintf)

			workflowsDir := filepath.Join(filepath.Dir(context.Path), "/workflows")
			templates := getWorkflowTemplates(workflowsDir, context)
			for _, templatePath := range templates {
				workflowName := getWorkflowName(workflowsDir, templatePath)
				input, err := ioutil.ReadFile(templatePath)
				if err != nil {
					panic(err)
				}
				workflow, err := vm.EvaluateSnippet(templatePath, string(input))
				destinationPath := ".github/workflows/" + workflowName + ".yml"
				meta := strings.Join([]string{
					"# File generated by g3ops, do not modify",
					fmt.Sprintf("# Source: %s", templatePath),
					fmt.Sprintf("# Created at: %s", time.Now().UTC().Format(time.RFC822)),
				}, "\n")
				err = ioutil.WriteFile(destinationPath, []byte(meta+"\n"+workflow), 0644)
				fmt.Println("Generated", destinationPath, "from", templatePath)
				if err != nil {
					panic(err)
				}
			}
		},
	}
}

func newCheckWorkflowCmd() *cobra.Command {
	return &cobra.Command{
		Use:   "check",
		Short: "Check workflow files are up to date",
		Run: func(cmd *cobra.Command, args []string) {
			context, err := lib.GetContext(cmd)
			if err != nil {
				fmt.Println(styles.StyleError(err.Error()))
				os.Exit(1)
			}
			err = lib.ValidateWorkflows(context)
			if err != nil {
				fmt.Println(styles.StyleError(err.Error()))
				os.Exit(1)
			} else {
				fmt.Println(styles.StyleCommand("Workflows up to date"))
			}
		},
	}
}

// WorkflowsCmd represents the context command
var WorkflowsCmd = &cobra.Command{
	Use: "workflows",
}

func init() {
	WorkflowsCmd.AddCommand(newGenerateWorkflowCmd())
	WorkflowsCmd.AddCommand(newCheckWorkflowCmd())
}
