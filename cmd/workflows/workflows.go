package workflows

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/fatih/color"
	"github.com/jbrunton/g3ops/cmd/styles"

	"github.com/google/go-jsonnet"
	"github.com/jbrunton/g3ops/lib"
	"github.com/spf13/cobra"
)

const template = `
local git_opts = {
  main_branch: 'master',
  user: 'jbrunton-ci-minion',
  email: 'jbrunton-ci-minion@outlook.com'
};

local build_job = {
  steps: [
    {
      name: 'commit',
      run: |||
        git config --global user.name "%(user)%s"
        git config --global user.email "%(email)%s"
        g3ops commit build ${{ matrix.service }}
        git push origin:%(main_branch)s
      ||| % git_opts
    }
  ]
};

local workflow = {
  on: {
    pull_request: {
      branches: [git_opts.main_branch]
    },
    push: {
      branches: [git_opts.main_branch]
    }
  },
  jobs: [
    build_job
  ],
};

std.manifestYamlDoc(workflow)
`

func newGenerateWorkflowCmd() *cobra.Command {
	return &cobra.Command{
		Use:   "generate",
		Short: "Generates workflow files",
		Run: func(cmd *cobra.Command, args []string) {
			context, err := lib.GetContext(cmd)
			if err != nil {
				fmt.Println(styles.StyleError(err.Error()))
				os.Exit(1)
			}

			vm := jsonnet.MakeVM()
			vm.StringOutput = true
			vm.ErrorFormatter.SetColorFormatter(color.New(color.FgRed).Fprintf)

			templatesGlob := filepath.Dir(context.Path) + "/workflows/*.jsonnet"
			templates, err := filepath.Glob(templatesGlob)
			if err != nil {
				panic(err)
			}
			for _, templatePath := range templates {
				_, templateFileName := filepath.Split(templatePath)
				templateName := strings.TrimSuffix(templateFileName, filepath.Ext(templateFileName))
				input, err := ioutil.ReadFile(templatePath)
				if err != nil {
					panic(err)
				}
				workflow, err := vm.EvaluateSnippet(templatePath, string(input))
				destinationPath := ".github/workflows/" + templateName + ".yml"
				meta := strings.Join([]string{
					"# File generated by g3ops, do not modify",
					fmt.Sprintf("# Source: %s", templatePath),
					fmt.Sprintf("# Created at: %s", time.Now().UTC().Format(time.RFC822)),
				}, "\n")
				err = ioutil.WriteFile(destinationPath, []byte(meta+"\n"+workflow), 0644)
				fmt.Println("Generated", destinationPath, "from", templatePath)
				if err != nil {
					panic(err)
				}
			}

			templatesGlob = filepath.Dir(context.Path) + "/workflows/*/template.jsonnet"
			templates, err = filepath.Glob(templatesGlob)
			if err != nil {
				panic(err)
			}
			for _, templatePath := range templates {
				templateDir, _ := filepath.Split(templatePath)
				templateName := filepath.Base(templateDir) //strings.TrimSuffix(templateFileName, filepath.Ext(templateFileName))
				input, err := ioutil.ReadFile(templatePath)
				if err != nil {
					panic(err)
				}
				workflow, err := vm.EvaluateSnippet(templatePath, string(input))
				destinationPath := ".github/workflows/" + templateName + ".yml"
				meta := strings.Join([]string{
					"# File generated by g3ops, do not modify",
					fmt.Sprintf("# Source: %s", templatePath),
					fmt.Sprintf("# Created at: %s", time.Now().UTC().Format(time.RFC822)),
				}, "\n")
				err = ioutil.WriteFile(destinationPath, []byte(meta+"\n"+workflow), 0644)
				fmt.Println("Generated", destinationPath, "from", templatePath)
				if err != nil {
					panic(err)
				}
			}
		},
	}
}

func newCheckWorkflowCmd() *cobra.Command {
	return &cobra.Command{
		Use:   "check",
		Short: "Check workflow files are up to date",
		Run: func(cmd *cobra.Command, args []string) {
			context, err := lib.GetContext(cmd)
			if err != nil {
				fmt.Println(styles.StyleError(err.Error()))
				os.Exit(1)
			}
			err = lib.ValidateWorkflows(context)
			if err != nil {
				fmt.Println(styles.StyleError(err.Error()))
				os.Exit(1)
			} else {
				fmt.Println(styles.StyleCommand("Workflows up to date"))
			}
		},
	}
}

// WorkflowsCmd represents the context command
var WorkflowsCmd = &cobra.Command{
	Use: "workflows",
}

func init() {
	WorkflowsCmd.AddCommand(newGenerateWorkflowCmd())
	WorkflowsCmd.AddCommand(newCheckWorkflowCmd())
}
