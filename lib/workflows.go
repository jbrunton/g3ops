package lib

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/fatih/color"
	"github.com/google/go-jsonnet"
)

func getWorkflowTemplates(workflowsDir string, context *G3opsContext) []string {
	files := []string{}
	err := filepath.Walk(workflowsDir, func(path string, f os.FileInfo, err error) error {
		if filepath.Ext(path) == ".jsonnet" {
			files = append(files, path)
		}
		return nil
	})

	if err != nil {
		panic(err)
	}

	return files
}

func getWorkflowName(workflowsDir string, filename string) string {
	templateDir, templateFileName := filepath.Split(filename)
	if templateFileName == "template.jsonnet" {
		// Check to see if the file is a top level template.
		if filepath.Clean(templateDir) != filepath.Clean(workflowsDir) {
			// If the file is called template.jsonnet and it's in a subdirectory, then rename it to the directory name.
			// E.g. "workflows/my-workflow/template.jsonnet" returns "my-workflow"
			return filepath.Base(templateDir)
		}
	}
	// In all other cases, simply return the name of the file less the extension.
	// E.g. "workflows/my-workflow.jsonnet" returns "my-workflow"
	return strings.TrimSuffix(templateFileName, filepath.Ext(templateFileName))
}

// GenerateWorkflows - generate workflow files for the given context
func GenerateWorkflows(context *G3opsContext) {
	vm := jsonnet.MakeVM()
	vm.StringOutput = true
	vm.ErrorFormatter.SetColorFormatter(color.New(color.FgRed).Fprintf)

	workflowsDir := filepath.Join(filepath.Dir(context.Path), "/workflows")
	templates := getWorkflowTemplates(workflowsDir, context)
	for _, templatePath := range templates {
		workflowName := getWorkflowName(workflowsDir, templatePath)
		input, err := ioutil.ReadFile(templatePath)
		if err != nil {
			panic(err)
		}
		workflow, err := vm.EvaluateSnippet(templatePath, string(input))
		destinationPath := ".github/workflows/" + workflowName + ".yml"
		meta := strings.Join([]string{
			"# File generated by g3ops, do not modify",
			fmt.Sprintf("# Source: %s", templatePath),
			fmt.Sprintf("# Created at: %s", time.Now().UTC().Format(time.RFC822)),
		}, "\n")
		err = ioutil.WriteFile(destinationPath, []byte(meta+"\n"+workflow), 0644)
		fmt.Println("Generated", destinationPath, "from", templatePath)
		if err != nil {
			panic(err)
		}
	}
}

// ValidateWorkflows - returns an error if the workflows are out of date
func ValidateWorkflows(context *G3opsContext) error {
	// 			expectedBuildWorkflow := GenerateWorkflow(context)
	// 			buildWorkflowFile := context.Config.Ci.Workflows.Build.Target
	// 			actualBuildWorkflow, err := ioutil.ReadFile(buildWorkflowFile)
	// 				if err != nil {
	// 							return err
	// 			}
	// 			if string(expectedBuildWorkflow) != string(actualBuildWorkflow) {
	// 							dmp := diffmatchpatch.New()
	// 							diffs := dmp.DiffMain(string(expectedBuildWorkflow), string(actualBuildWorkflow), false)
	// 							fmt.Printf("Workflow %q is out of date. Diff:\n%s", buildWorkflowFile, dmp.DiffPrettyText(diffs))
	// 							return errors.New("Workflows are out of date, please run g3ops workflows generate")
	// +               panic(err)
	// 				}
	return nil
}
